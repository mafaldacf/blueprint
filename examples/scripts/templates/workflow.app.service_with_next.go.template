package {{.PkgName}}

import (
	"context"
	{{- if .HasDB }}

	"github.com/blueprint-uservices/blueprint/runtime/core/backend"
	{{- end }}
)

type Service{{.N}}Data struct {
	ID   string `bson:"id"`
	Data string `bson:"data"`
}

type Service{{.N}} interface {
	{{- range $idx := .Methods }}
	// Endpoint {{$idx}}
	Method{{$.N}}_{{$idx}}(ctx context.Context, id string, data string) (Service{{$.N}}Data, error)
	{{- end }}
}

type Service{{.N}}Impl struct {
	{{- if .HasDB }}
	service{{.N}}DB backend.NoSQLDatabase
	{{- end }}
	{{- range $i, $next := .Next }}
	service{{$next}} Service{{$next}}
	{{- end }}
}

func NewService{{.N}}Impl(
	ctx context.Context,
	{{- if .HasDB }}
	service{{.N}}DB backend.NoSQLDatabase,
	{{- end }}
	{{- range $i, $next := .Next }}
	service{{$next}} Service{{$next}},
	{{- end }}
) (Service{{.N}}, error) {
	return &Service{{.N}}Impl{
		{{- if .HasDB }}
		service{{.N}}DB: service{{.N}}DB,
		{{- end }}
		{{- range $i, $next := .Next }}
		service{{$next}}: service{{$next}},
		{{- end }}
	}, nil
}

{{- range $idx := .Methods }}

func (s *Service{{$.N}}Impl) Method{{$.N}}_{{$idx}}(ctx context.Context, id{{$.N}} string, data{{$.N}} string) (Service{{$.N}}Data, error) {
	// Prepare response payload
	service{{$.N}}Data := Service{{$.N}}Data{
		ID:   id{{$.N}},
		Data: data{{$.N}},
	}

	{{- if $.HasDB }}
	// ----------------------- DATABASE WRITE -----------------------
	coll, err := s.service{{$.N}}DB.GetCollection(ctx, "service{{$.N}}_db", "service{{$.N}}_data")
	if err != nil {
		return Service{{$.N}}Data{}, err
	}
	if err := coll.InsertOne(ctx, service{{$.N}}Data); err != nil {
		return Service{{$.N}}Data{}, err
	}
	{{- end }}

	// ----------------------- SERVICES RPCs -----------------------
	// call the next services in the chain for endpoint {{$idx}}
	{{- range $j, $next := $.Next }}
	if _, err := s.service{{$next}}.Method{{$next}}_{{$idx}}(ctx, id{{$.N}}, data{{$.N}}); err != nil {
		return Service{{$.N}}Data{}, err
	}
	{{- end }}

	return service{{$.N}}Data, nil
}

{{- end }}
