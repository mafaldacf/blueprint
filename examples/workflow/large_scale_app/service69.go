// Code generated by gen_workflow.go
		
package large_scale_app

import (
	"context"

	"github.com/blueprint-uservices/blueprint/runtime/core/backend"
	"go.mongodb.org/mongo-driver/bson"
)

type Service69Data struct {
	id   string
	data string
}

type Service69 interface {
	Method69(ctx context.Context, id string, data string) (Service69Data, error)
}

type Service69Impl struct {
	service69DB backend.NoSQLDatabase
	service70   Service70
}

func NewService69Impl(ctx context.Context, service69DB backend.NoSQLDatabase, service70 Service70) (Service69, error) {
	return &Service69Impl{
		service69DB: service69DB,
		service70:   service70,
	}, nil
}

func (s *Service69Impl) Method69(ctx context.Context, id69 string, data69 string) (Service69Data, error) {
	// ----------------------- READ -----------------------
	coll, err := s.service69DB.GetCollection(ctx, "service69_db", "service69_data")
	if err != nil {
		return Service69Data{}, err
	}
	query := bson.D{{Key: "id", Value: id69}}
	res, err := coll.FindOne(ctx, query)
	if err != nil {
		return Service69Data{}, err
	}
	var service69Data Service69Data
	exists, err := res.One(ctx, &service69Data)
	if err != nil {
		return Service69Data{}, err
	}
	if exists {
		return service69Data, nil
	}

	// ----------------------- WRITE -----------------------
	coll, err = s.service69DB.GetCollection(ctx, "service69_db", "service69_data")
	if err != nil {
		return Service69Data{}, err
	}
	service69Data = Service69Data{
		id:   id69,
		data: data69,
	}
	if err := coll.InsertOne(ctx, service69Data); err != nil {
		return Service69Data{}, err
	}

	// call the next service in the chain
	if _, err := s.service70.Method70(ctx, id69, data69); err != nil {
		return Service69Data{}, err
	}

	return service69Data, nil
}
