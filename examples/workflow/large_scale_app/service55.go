// Code generated by gen_workflow.go
		
package large_scale_app

import (
	"context"

	"github.com/blueprint-uservices/blueprint/runtime/core/backend"
	"go.mongodb.org/mongo-driver/bson"
)

type Service55Data struct {
	id   string
	data string
}

type Service55 interface {
	Method55(ctx context.Context, id string, data string) (Service55Data, error)
}

type Service55Impl struct {
	service55DB backend.NoSQLDatabase
	service56   Service56
}

func NewService55Impl(ctx context.Context, service55DB backend.NoSQLDatabase, service56 Service56) (Service55, error) {
	return &Service55Impl{
		service55DB: service55DB,
		service56:   service56,
	}, nil
}

func (s *Service55Impl) Method55(ctx context.Context, id55 string, data55 string) (Service55Data, error) {
	// ----------------------- READ -----------------------
	coll, err := s.service55DB.GetCollection(ctx, "service55_db", "service55_data")
	if err != nil {
		return Service55Data{}, err
	}
	query := bson.D{{Key: "id", Value: id55}}
	res, err := coll.FindOne(ctx, query)
	if err != nil {
		return Service55Data{}, err
	}
	var service55Data Service55Data
	exists, err := res.One(ctx, &service55Data)
	if err != nil {
		return Service55Data{}, err
	}
	if exists {
		return service55Data, nil
	}

	// ----------------------- WRITE -----------------------
	coll, err = s.service55DB.GetCollection(ctx, "service55_db", "service55_data")
	if err != nil {
		return Service55Data{}, err
	}
	service55Data = Service55Data{
		id:   id55,
		data: data55,
	}
	if err := coll.InsertOne(ctx, service55Data); err != nil {
		return Service55Data{}, err
	}

	// call the next service in the chain
	if _, err := s.service56.Method56(ctx, id55, data55); err != nil {
		return Service55Data{}, err
	}

	return service55Data, nil
}
